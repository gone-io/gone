// Code generated by MockGen. DO NOT EDIT.
// Source: transaction.go
//
// Generated by this command:
//
//	mockgen -package xorm -destination=./session_mock_test.go -source transaction.go XInterface
//

// Package xorm is a generated GoMock package.
package xorm

import (
	sql "database/sql"
	reflect "reflect"

	gomock "go.uber.org/mock/gomock"
	xorm "xorm.io/xorm"
)

// MockXInterface is a mock of XInterface interface.
type MockXInterface struct {
	ctrl     *gomock.Controller
	recorder *MockXInterfaceMockRecorder
	isgomock struct{}
}

// MockXInterfaceMockRecorder is the mock recorder for MockXInterface.
type MockXInterfaceMockRecorder struct {
	mock *MockXInterface
}

// NewMockXInterface creates a new mock instance.
func NewMockXInterface(ctrl *gomock.Controller) *MockXInterface {
	mock := &MockXInterface{ctrl: ctrl}
	mock.recorder = &MockXInterfaceMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockXInterface) EXPECT() *MockXInterfaceMockRecorder {
	return m.recorder
}

// Alias mocks base method.
func (m *MockXInterface) Alias(alias string) *xorm.Session {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Alias", alias)
	ret0, _ := ret[0].(*xorm.Session)
	return ret0
}

// Alias indicates an expected call of Alias.
func (mr *MockXInterfaceMockRecorder) Alias(alias any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Alias", reflect.TypeOf((*MockXInterface)(nil).Alias), alias)
}

// AllCols mocks base method.
func (m *MockXInterface) AllCols() *xorm.Session {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "AllCols")
	ret0, _ := ret[0].(*xorm.Session)
	return ret0
}

// AllCols indicates an expected call of AllCols.
func (mr *MockXInterfaceMockRecorder) AllCols() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "AllCols", reflect.TypeOf((*MockXInterface)(nil).AllCols))
}

// Asc mocks base method.
func (m *MockXInterface) Asc(colNames ...string) *xorm.Session {
	m.ctrl.T.Helper()
	varargs := []any{}
	for _, a := range colNames {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "Asc", varargs...)
	ret0, _ := ret[0].(*xorm.Session)
	return ret0
}

// Asc indicates an expected call of Asc.
func (mr *MockXInterfaceMockRecorder) Asc(colNames ...any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Asc", reflect.TypeOf((*MockXInterface)(nil).Asc), colNames...)
}

// Begin mocks base method.
func (m *MockXInterface) Begin() error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Begin")
	ret0, _ := ret[0].(error)
	return ret0
}

// Begin indicates an expected call of Begin.
func (mr *MockXInterfaceMockRecorder) Begin() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Begin", reflect.TypeOf((*MockXInterface)(nil).Begin))
}

// BufferSize mocks base method.
func (m *MockXInterface) BufferSize(size int) *xorm.Session {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "BufferSize", size)
	ret0, _ := ret[0].(*xorm.Session)
	return ret0
}

// BufferSize indicates an expected call of BufferSize.
func (mr *MockXInterfaceMockRecorder) BufferSize(size any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "BufferSize", reflect.TypeOf((*MockXInterface)(nil).BufferSize), size)
}

// Close mocks base method.
func (m *MockXInterface) Close() error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Close")
	ret0, _ := ret[0].(error)
	return ret0
}

// Close indicates an expected call of Close.
func (mr *MockXInterfaceMockRecorder) Close() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Close", reflect.TypeOf((*MockXInterface)(nil).Close))
}

// Cols mocks base method.
func (m *MockXInterface) Cols(columns ...string) *xorm.Session {
	m.ctrl.T.Helper()
	varargs := []any{}
	for _, a := range columns {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "Cols", varargs...)
	ret0, _ := ret[0].(*xorm.Session)
	return ret0
}

// Cols indicates an expected call of Cols.
func (mr *MockXInterfaceMockRecorder) Cols(columns ...any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Cols", reflect.TypeOf((*MockXInterface)(nil).Cols), columns...)
}

// Commit mocks base method.
func (m *MockXInterface) Commit() error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Commit")
	ret0, _ := ret[0].(error)
	return ret0
}

// Commit indicates an expected call of Commit.
func (mr *MockXInterfaceMockRecorder) Commit() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Commit", reflect.TypeOf((*MockXInterface)(nil).Commit))
}

// Count mocks base method.
func (m *MockXInterface) Count(arg0 ...any) (int64, error) {
	m.ctrl.T.Helper()
	varargs := []any{}
	for _, a := range arg0 {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "Count", varargs...)
	ret0, _ := ret[0].(int64)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Count indicates an expected call of Count.
func (mr *MockXInterfaceMockRecorder) Count(arg0 ...any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Count", reflect.TypeOf((*MockXInterface)(nil).Count), arg0...)
}

// CreateIndexes mocks base method.
func (m *MockXInterface) CreateIndexes(bean any) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "CreateIndexes", bean)
	ret0, _ := ret[0].(error)
	return ret0
}

// CreateIndexes indicates an expected call of CreateIndexes.
func (mr *MockXInterfaceMockRecorder) CreateIndexes(bean any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CreateIndexes", reflect.TypeOf((*MockXInterface)(nil).CreateIndexes), bean)
}

// CreateUniques mocks base method.
func (m *MockXInterface) CreateUniques(bean any) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "CreateUniques", bean)
	ret0, _ := ret[0].(error)
	return ret0
}

// CreateUniques indicates an expected call of CreateUniques.
func (mr *MockXInterfaceMockRecorder) CreateUniques(bean any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CreateUniques", reflect.TypeOf((*MockXInterface)(nil).CreateUniques), bean)
}

// Decr mocks base method.
func (m *MockXInterface) Decr(column string, arg ...any) *xorm.Session {
	m.ctrl.T.Helper()
	varargs := []any{column}
	for _, a := range arg {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "Decr", varargs...)
	ret0, _ := ret[0].(*xorm.Session)
	return ret0
}

// Decr indicates an expected call of Decr.
func (mr *MockXInterfaceMockRecorder) Decr(column any, arg ...any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{column}, arg...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Decr", reflect.TypeOf((*MockXInterface)(nil).Decr), varargs...)
}

// Delete mocks base method.
func (m *MockXInterface) Delete(arg0 ...any) (int64, error) {
	m.ctrl.T.Helper()
	varargs := []any{}
	for _, a := range arg0 {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "Delete", varargs...)
	ret0, _ := ret[0].(int64)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Delete indicates an expected call of Delete.
func (mr *MockXInterfaceMockRecorder) Delete(arg0 ...any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Delete", reflect.TypeOf((*MockXInterface)(nil).Delete), arg0...)
}

// Desc mocks base method.
func (m *MockXInterface) Desc(arg0 ...string) *xorm.Session {
	m.ctrl.T.Helper()
	varargs := []any{}
	for _, a := range arg0 {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "Desc", varargs...)
	ret0, _ := ret[0].(*xorm.Session)
	return ret0
}

// Desc indicates an expected call of Desc.
func (mr *MockXInterfaceMockRecorder) Desc(arg0 ...any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Desc", reflect.TypeOf((*MockXInterface)(nil).Desc), arg0...)
}

// Distinct mocks base method.
func (m *MockXInterface) Distinct(columns ...string) *xorm.Session {
	m.ctrl.T.Helper()
	varargs := []any{}
	for _, a := range columns {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "Distinct", varargs...)
	ret0, _ := ret[0].(*xorm.Session)
	return ret0
}

// Distinct indicates an expected call of Distinct.
func (mr *MockXInterfaceMockRecorder) Distinct(columns ...any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Distinct", reflect.TypeOf((*MockXInterface)(nil).Distinct), columns...)
}

// DropIndexes mocks base method.
func (m *MockXInterface) DropIndexes(bean any) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "DropIndexes", bean)
	ret0, _ := ret[0].(error)
	return ret0
}

// DropIndexes indicates an expected call of DropIndexes.
func (mr *MockXInterfaceMockRecorder) DropIndexes(bean any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "DropIndexes", reflect.TypeOf((*MockXInterface)(nil).DropIndexes), bean)
}

// Exec mocks base method.
func (m *MockXInterface) Exec(sqlOrArgs ...any) (sql.Result, error) {
	m.ctrl.T.Helper()
	varargs := []any{}
	for _, a := range sqlOrArgs {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "Exec", varargs...)
	ret0, _ := ret[0].(sql.Result)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Exec indicates an expected call of Exec.
func (mr *MockXInterfaceMockRecorder) Exec(sqlOrArgs ...any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Exec", reflect.TypeOf((*MockXInterface)(nil).Exec), sqlOrArgs...)
}

// Exist mocks base method.
func (m *MockXInterface) Exist(bean ...any) (bool, error) {
	m.ctrl.T.Helper()
	varargs := []any{}
	for _, a := range bean {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "Exist", varargs...)
	ret0, _ := ret[0].(bool)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Exist indicates an expected call of Exist.
func (mr *MockXInterfaceMockRecorder) Exist(bean ...any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Exist", reflect.TypeOf((*MockXInterface)(nil).Exist), bean...)
}

// Find mocks base method.
func (m *MockXInterface) Find(arg0 any, arg1 ...any) error {
	m.ctrl.T.Helper()
	varargs := []any{arg0}
	for _, a := range arg1 {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "Find", varargs...)
	ret0, _ := ret[0].(error)
	return ret0
}

// Find indicates an expected call of Find.
func (mr *MockXInterfaceMockRecorder) Find(arg0 any, arg1 ...any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{arg0}, arg1...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Find", reflect.TypeOf((*MockXInterface)(nil).Find), varargs...)
}

// FindAndCount mocks base method.
func (m *MockXInterface) FindAndCount(arg0 any, arg1 ...any) (int64, error) {
	m.ctrl.T.Helper()
	varargs := []any{arg0}
	for _, a := range arg1 {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "FindAndCount", varargs...)
	ret0, _ := ret[0].(int64)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// FindAndCount indicates an expected call of FindAndCount.
func (mr *MockXInterfaceMockRecorder) FindAndCount(arg0 any, arg1 ...any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{arg0}, arg1...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "FindAndCount", reflect.TypeOf((*MockXInterface)(nil).FindAndCount), varargs...)
}

// Get mocks base method.
func (m *MockXInterface) Get(arg0 ...any) (bool, error) {
	m.ctrl.T.Helper()
	varargs := []any{}
	for _, a := range arg0 {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "Get", varargs...)
	ret0, _ := ret[0].(bool)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Get indicates an expected call of Get.
func (mr *MockXInterfaceMockRecorder) Get(arg0 ...any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Get", reflect.TypeOf((*MockXInterface)(nil).Get), arg0...)
}

// GroupBy mocks base method.
func (m *MockXInterface) GroupBy(keys string) *xorm.Session {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GroupBy", keys)
	ret0, _ := ret[0].(*xorm.Session)
	return ret0
}

// GroupBy indicates an expected call of GroupBy.
func (mr *MockXInterfaceMockRecorder) GroupBy(keys any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GroupBy", reflect.TypeOf((*MockXInterface)(nil).GroupBy), keys)
}

// ID mocks base method.
func (m *MockXInterface) ID(arg0 any) *xorm.Session {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "ID", arg0)
	ret0, _ := ret[0].(*xorm.Session)
	return ret0
}

// ID indicates an expected call of ID.
func (mr *MockXInterfaceMockRecorder) ID(arg0 any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ID", reflect.TypeOf((*MockXInterface)(nil).ID), arg0)
}

// In mocks base method.
func (m *MockXInterface) In(arg0 string, arg1 ...any) *xorm.Session {
	m.ctrl.T.Helper()
	varargs := []any{arg0}
	for _, a := range arg1 {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "In", varargs...)
	ret0, _ := ret[0].(*xorm.Session)
	return ret0
}

// In indicates an expected call of In.
func (mr *MockXInterfaceMockRecorder) In(arg0 any, arg1 ...any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{arg0}, arg1...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "In", reflect.TypeOf((*MockXInterface)(nil).In), varargs...)
}

// Incr mocks base method.
func (m *MockXInterface) Incr(column string, arg ...any) *xorm.Session {
	m.ctrl.T.Helper()
	varargs := []any{column}
	for _, a := range arg {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "Incr", varargs...)
	ret0, _ := ret[0].(*xorm.Session)
	return ret0
}

// Incr indicates an expected call of Incr.
func (mr *MockXInterfaceMockRecorder) Incr(column any, arg ...any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{column}, arg...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Incr", reflect.TypeOf((*MockXInterface)(nil).Incr), varargs...)
}

// Insert mocks base method.
func (m *MockXInterface) Insert(arg0 ...any) (int64, error) {
	m.ctrl.T.Helper()
	varargs := []any{}
	for _, a := range arg0 {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "Insert", varargs...)
	ret0, _ := ret[0].(int64)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Insert indicates an expected call of Insert.
func (mr *MockXInterfaceMockRecorder) Insert(arg0 ...any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Insert", reflect.TypeOf((*MockXInterface)(nil).Insert), arg0...)
}

// InsertOne mocks base method.
func (m *MockXInterface) InsertOne(arg0 any) (int64, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "InsertOne", arg0)
	ret0, _ := ret[0].(int64)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// InsertOne indicates an expected call of InsertOne.
func (mr *MockXInterfaceMockRecorder) InsertOne(arg0 any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "InsertOne", reflect.TypeOf((*MockXInterface)(nil).InsertOne), arg0)
}

// IsTableEmpty mocks base method.
func (m *MockXInterface) IsTableEmpty(bean any) (bool, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "IsTableEmpty", bean)
	ret0, _ := ret[0].(bool)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// IsTableEmpty indicates an expected call of IsTableEmpty.
func (mr *MockXInterfaceMockRecorder) IsTableEmpty(bean any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "IsTableEmpty", reflect.TypeOf((*MockXInterface)(nil).IsTableEmpty), bean)
}

// IsTableExist mocks base method.
func (m *MockXInterface) IsTableExist(beanOrTableName any) (bool, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "IsTableExist", beanOrTableName)
	ret0, _ := ret[0].(bool)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// IsTableExist indicates an expected call of IsTableExist.
func (mr *MockXInterfaceMockRecorder) IsTableExist(beanOrTableName any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "IsTableExist", reflect.TypeOf((*MockXInterface)(nil).IsTableExist), beanOrTableName)
}

// Iterate mocks base method.
func (m *MockXInterface) Iterate(arg0 any, arg1 xorm.IterFunc) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Iterate", arg0, arg1)
	ret0, _ := ret[0].(error)
	return ret0
}

// Iterate indicates an expected call of Iterate.
func (mr *MockXInterfaceMockRecorder) Iterate(arg0, arg1 any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Iterate", reflect.TypeOf((*MockXInterface)(nil).Iterate), arg0, arg1)
}

// Join mocks base method.
func (m *MockXInterface) Join(joinOperator string, tablename, condition any, args ...any) *xorm.Session {
	m.ctrl.T.Helper()
	varargs := []any{joinOperator, tablename, condition}
	for _, a := range args {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "Join", varargs...)
	ret0, _ := ret[0].(*xorm.Session)
	return ret0
}

// Join indicates an expected call of Join.
func (mr *MockXInterfaceMockRecorder) Join(joinOperator, tablename, condition any, args ...any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{joinOperator, tablename, condition}, args...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Join", reflect.TypeOf((*MockXInterface)(nil).Join), varargs...)
}

// Limit mocks base method.
func (m *MockXInterface) Limit(arg0 int, arg1 ...int) *xorm.Session {
	m.ctrl.T.Helper()
	varargs := []any{arg0}
	for _, a := range arg1 {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "Limit", varargs...)
	ret0, _ := ret[0].(*xorm.Session)
	return ret0
}

// Limit indicates an expected call of Limit.
func (mr *MockXInterfaceMockRecorder) Limit(arg0 any, arg1 ...any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{arg0}, arg1...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Limit", reflect.TypeOf((*MockXInterface)(nil).Limit), varargs...)
}

// MustCols mocks base method.
func (m *MockXInterface) MustCols(columns ...string) *xorm.Session {
	m.ctrl.T.Helper()
	varargs := []any{}
	for _, a := range columns {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "MustCols", varargs...)
	ret0, _ := ret[0].(*xorm.Session)
	return ret0
}

// MustCols indicates an expected call of MustCols.
func (mr *MockXInterfaceMockRecorder) MustCols(columns ...any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "MustCols", reflect.TypeOf((*MockXInterface)(nil).MustCols), columns...)
}

// NoAutoCondition mocks base method.
func (m *MockXInterface) NoAutoCondition(arg0 ...bool) *xorm.Session {
	m.ctrl.T.Helper()
	varargs := []any{}
	for _, a := range arg0 {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "NoAutoCondition", varargs...)
	ret0, _ := ret[0].(*xorm.Session)
	return ret0
}

// NoAutoCondition indicates an expected call of NoAutoCondition.
func (mr *MockXInterfaceMockRecorder) NoAutoCondition(arg0 ...any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "NoAutoCondition", reflect.TypeOf((*MockXInterface)(nil).NoAutoCondition), arg0...)
}

// NotIn mocks base method.
func (m *MockXInterface) NotIn(arg0 string, arg1 ...any) *xorm.Session {
	m.ctrl.T.Helper()
	varargs := []any{arg0}
	for _, a := range arg1 {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "NotIn", varargs...)
	ret0, _ := ret[0].(*xorm.Session)
	return ret0
}

// NotIn indicates an expected call of NotIn.
func (mr *MockXInterfaceMockRecorder) NotIn(arg0 any, arg1 ...any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{arg0}, arg1...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "NotIn", reflect.TypeOf((*MockXInterface)(nil).NotIn), varargs...)
}

// Nullable mocks base method.
func (m *MockXInterface) Nullable(arg0 ...string) *xorm.Session {
	m.ctrl.T.Helper()
	varargs := []any{}
	for _, a := range arg0 {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "Nullable", varargs...)
	ret0, _ := ret[0].(*xorm.Session)
	return ret0
}

// Nullable indicates an expected call of Nullable.
func (mr *MockXInterfaceMockRecorder) Nullable(arg0 ...any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Nullable", reflect.TypeOf((*MockXInterface)(nil).Nullable), arg0...)
}

// Omit mocks base method.
func (m *MockXInterface) Omit(columns ...string) *xorm.Session {
	m.ctrl.T.Helper()
	varargs := []any{}
	for _, a := range columns {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "Omit", varargs...)
	ret0, _ := ret[0].(*xorm.Session)
	return ret0
}

// Omit indicates an expected call of Omit.
func (mr *MockXInterfaceMockRecorder) Omit(columns ...any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Omit", reflect.TypeOf((*MockXInterface)(nil).Omit), columns...)
}

// OrderBy mocks base method.
func (m *MockXInterface) OrderBy(order any, args ...any) *xorm.Session {
	m.ctrl.T.Helper()
	varargs := []any{order}
	for _, a := range args {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "OrderBy", varargs...)
	ret0, _ := ret[0].(*xorm.Session)
	return ret0
}

// OrderBy indicates an expected call of OrderBy.
func (mr *MockXInterfaceMockRecorder) OrderBy(order any, args ...any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{order}, args...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "OrderBy", reflect.TypeOf((*MockXInterface)(nil).OrderBy), varargs...)
}

// Ping mocks base method.
func (m *MockXInterface) Ping() error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Ping")
	ret0, _ := ret[0].(error)
	return ret0
}

// Ping indicates an expected call of Ping.
func (mr *MockXInterfaceMockRecorder) Ping() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Ping", reflect.TypeOf((*MockXInterface)(nil).Ping))
}

// Query mocks base method.
func (m *MockXInterface) Query(sqlOrArgs ...any) ([]map[string][]byte, error) {
	m.ctrl.T.Helper()
	varargs := []any{}
	for _, a := range sqlOrArgs {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "Query", varargs...)
	ret0, _ := ret[0].([]map[string][]byte)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Query indicates an expected call of Query.
func (mr *MockXInterfaceMockRecorder) Query(sqlOrArgs ...any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Query", reflect.TypeOf((*MockXInterface)(nil).Query), sqlOrArgs...)
}

// QueryInterface mocks base method.
func (m *MockXInterface) QueryInterface(sqlOrArgs ...any) ([]map[string]any, error) {
	m.ctrl.T.Helper()
	varargs := []any{}
	for _, a := range sqlOrArgs {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "QueryInterface", varargs...)
	ret0, _ := ret[0].([]map[string]any)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// QueryInterface indicates an expected call of QueryInterface.
func (mr *MockXInterfaceMockRecorder) QueryInterface(sqlOrArgs ...any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "QueryInterface", reflect.TypeOf((*MockXInterface)(nil).QueryInterface), sqlOrArgs...)
}

// QueryString mocks base method.
func (m *MockXInterface) QueryString(sqlOrArgs ...any) ([]map[string]string, error) {
	m.ctrl.T.Helper()
	varargs := []any{}
	for _, a := range sqlOrArgs {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "QueryString", varargs...)
	ret0, _ := ret[0].([]map[string]string)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// QueryString indicates an expected call of QueryString.
func (mr *MockXInterfaceMockRecorder) QueryString(sqlOrArgs ...any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "QueryString", reflect.TypeOf((*MockXInterface)(nil).QueryString), sqlOrArgs...)
}

// Rollback mocks base method.
func (m *MockXInterface) Rollback() error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Rollback")
	ret0, _ := ret[0].(error)
	return ret0
}

// Rollback indicates an expected call of Rollback.
func (mr *MockXInterfaceMockRecorder) Rollback() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Rollback", reflect.TypeOf((*MockXInterface)(nil).Rollback))
}

// Rows mocks base method.
func (m *MockXInterface) Rows(bean any) (*xorm.Rows, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Rows", bean)
	ret0, _ := ret[0].(*xorm.Rows)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Rows indicates an expected call of Rows.
func (mr *MockXInterfaceMockRecorder) Rows(bean any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Rows", reflect.TypeOf((*MockXInterface)(nil).Rows), bean)
}

// SQL mocks base method.
func (m *MockXInterface) SQL(arg0 any, arg1 ...any) *xorm.Session {
	m.ctrl.T.Helper()
	varargs := []any{arg0}
	for _, a := range arg1 {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "SQL", varargs...)
	ret0, _ := ret[0].(*xorm.Session)
	return ret0
}

// SQL indicates an expected call of SQL.
func (mr *MockXInterfaceMockRecorder) SQL(arg0 any, arg1 ...any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{arg0}, arg1...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SQL", reflect.TypeOf((*MockXInterface)(nil).SQL), varargs...)
}

// Select mocks base method.
func (m *MockXInterface) Select(arg0 string) *xorm.Session {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Select", arg0)
	ret0, _ := ret[0].(*xorm.Session)
	return ret0
}

// Select indicates an expected call of Select.
func (mr *MockXInterfaceMockRecorder) Select(arg0 any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Select", reflect.TypeOf((*MockXInterface)(nil).Select), arg0)
}

// SetExpr mocks base method.
func (m *MockXInterface) SetExpr(arg0 string, arg1 any) *xorm.Session {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "SetExpr", arg0, arg1)
	ret0, _ := ret[0].(*xorm.Session)
	return ret0
}

// SetExpr indicates an expected call of SetExpr.
func (mr *MockXInterfaceMockRecorder) SetExpr(arg0, arg1 any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SetExpr", reflect.TypeOf((*MockXInterface)(nil).SetExpr), arg0, arg1)
}

// Sum mocks base method.
func (m *MockXInterface) Sum(bean any, colName string) (float64, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Sum", bean, colName)
	ret0, _ := ret[0].(float64)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Sum indicates an expected call of Sum.
func (mr *MockXInterfaceMockRecorder) Sum(bean, colName any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Sum", reflect.TypeOf((*MockXInterface)(nil).Sum), bean, colName)
}

// SumInt mocks base method.
func (m *MockXInterface) SumInt(bean any, colName string) (int64, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "SumInt", bean, colName)
	ret0, _ := ret[0].(int64)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// SumInt indicates an expected call of SumInt.
func (mr *MockXInterfaceMockRecorder) SumInt(bean, colName any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SumInt", reflect.TypeOf((*MockXInterface)(nil).SumInt), bean, colName)
}

// Sums mocks base method.
func (m *MockXInterface) Sums(bean any, colNames ...string) ([]float64, error) {
	m.ctrl.T.Helper()
	varargs := []any{bean}
	for _, a := range colNames {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "Sums", varargs...)
	ret0, _ := ret[0].([]float64)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Sums indicates an expected call of Sums.
func (mr *MockXInterfaceMockRecorder) Sums(bean any, colNames ...any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{bean}, colNames...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Sums", reflect.TypeOf((*MockXInterface)(nil).Sums), varargs...)
}

// SumsInt mocks base method.
func (m *MockXInterface) SumsInt(bean any, colNames ...string) ([]int64, error) {
	m.ctrl.T.Helper()
	varargs := []any{bean}
	for _, a := range colNames {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "SumsInt", varargs...)
	ret0, _ := ret[0].([]int64)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// SumsInt indicates an expected call of SumsInt.
func (mr *MockXInterfaceMockRecorder) SumsInt(bean any, colNames ...any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{bean}, colNames...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SumsInt", reflect.TypeOf((*MockXInterface)(nil).SumsInt), varargs...)
}

// Table mocks base method.
func (m *MockXInterface) Table(tableNameOrBean any) *xorm.Session {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Table", tableNameOrBean)
	ret0, _ := ret[0].(*xorm.Session)
	return ret0
}

// Table indicates an expected call of Table.
func (mr *MockXInterfaceMockRecorder) Table(tableNameOrBean any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Table", reflect.TypeOf((*MockXInterface)(nil).Table), tableNameOrBean)
}

// Truncate mocks base method.
func (m *MockXInterface) Truncate(arg0 ...any) (int64, error) {
	m.ctrl.T.Helper()
	varargs := []any{}
	for _, a := range arg0 {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "Truncate", varargs...)
	ret0, _ := ret[0].(int64)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Truncate indicates an expected call of Truncate.
func (mr *MockXInterfaceMockRecorder) Truncate(arg0 ...any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Truncate", reflect.TypeOf((*MockXInterface)(nil).Truncate), arg0...)
}

// Unscoped mocks base method.
func (m *MockXInterface) Unscoped() *xorm.Session {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Unscoped")
	ret0, _ := ret[0].(*xorm.Session)
	return ret0
}

// Unscoped indicates an expected call of Unscoped.
func (mr *MockXInterfaceMockRecorder) Unscoped() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Unscoped", reflect.TypeOf((*MockXInterface)(nil).Unscoped))
}

// Update mocks base method.
func (m *MockXInterface) Update(bean any, condiBeans ...any) (int64, error) {
	m.ctrl.T.Helper()
	varargs := []any{bean}
	for _, a := range condiBeans {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "Update", varargs...)
	ret0, _ := ret[0].(int64)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Update indicates an expected call of Update.
func (mr *MockXInterfaceMockRecorder) Update(bean any, condiBeans ...any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{bean}, condiBeans...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Update", reflect.TypeOf((*MockXInterface)(nil).Update), varargs...)
}

// UseBool mocks base method.
func (m *MockXInterface) UseBool(arg0 ...string) *xorm.Session {
	m.ctrl.T.Helper()
	varargs := []any{}
	for _, a := range arg0 {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "UseBool", varargs...)
	ret0, _ := ret[0].(*xorm.Session)
	return ret0
}

// UseBool indicates an expected call of UseBool.
func (mr *MockXInterfaceMockRecorder) UseBool(arg0 ...any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "UseBool", reflect.TypeOf((*MockXInterface)(nil).UseBool), arg0...)
}

// Where mocks base method.
func (m *MockXInterface) Where(arg0 any, arg1 ...any) *xorm.Session {
	m.ctrl.T.Helper()
	varargs := []any{arg0}
	for _, a := range arg1 {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "Where", varargs...)
	ret0, _ := ret[0].(*xorm.Session)
	return ret0
}

// Where indicates an expected call of Where.
func (mr *MockXInterfaceMockRecorder) Where(arg0 any, arg1 ...any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{arg0}, arg1...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Where", reflect.TypeOf((*MockXInterface)(nil).Where), varargs...)
}
