// Code generated by MockGen. DO NOT EDIT.
// Source: transaction.go

// Package xorm is a generated GoMock package.
package xorm

import (
	sql "database/sql"
	reflect "reflect"

	gomock "github.com/golang/mock/gomock"
	xorm "xorm.io/xorm"
)

// MockXInterface is a mock of XInterface interface.
type MockXInterface struct {
	ctrl     *gomock.Controller
	recorder *MockXInterfaceMockRecorder
}

// MockXInterfaceMockRecorder is the mock recorder for MockXInterface.
type MockXInterfaceMockRecorder struct {
	mock *MockXInterface
}

// NewMockXInterface creates a new mock instance.
func NewMockXInterface(ctrl *gomock.Controller) *MockXInterface {
	mock := &MockXInterface{ctrl: ctrl}
	mock.recorder = &MockXInterfaceMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockXInterface) EXPECT() *MockXInterfaceMockRecorder {
	return m.recorder
}

// Alias mocks base method.
func (m *MockXInterface) Alias(alias string) *xorm.Session {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Alias", alias)
	ret0, _ := ret[0].(*xorm.Session)
	return ret0
}

// Alias indicates an expected call of Alias.
func (mr *MockXInterfaceMockRecorder) Alias(alias interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Alias", reflect.TypeOf((*MockXInterface)(nil).Alias), alias)
}

// AllCols mocks base method.
func (m *MockXInterface) AllCols() *xorm.Session {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "AllCols")
	ret0, _ := ret[0].(*xorm.Session)
	return ret0
}

// AllCols indicates an expected call of AllCols.
func (mr *MockXInterfaceMockRecorder) AllCols() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "AllCols", reflect.TypeOf((*MockXInterface)(nil).AllCols))
}

// Asc mocks base method.
func (m *MockXInterface) Asc(colNames ...string) *xorm.Session {
	m.ctrl.T.Helper()
	varargs := []interface{}{}
	for _, a := range colNames {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "Asc", varargs...)
	ret0, _ := ret[0].(*xorm.Session)
	return ret0
}

// Asc indicates an expected call of Asc.
func (mr *MockXInterfaceMockRecorder) Asc(colNames ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Asc", reflect.TypeOf((*MockXInterface)(nil).Asc), colNames...)
}

// Begin mocks base method.
func (m *MockXInterface) Begin() error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Begin")
	ret0, _ := ret[0].(error)
	return ret0
}

// Begin indicates an expected call of Begin.
func (mr *MockXInterfaceMockRecorder) Begin() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Begin", reflect.TypeOf((*MockXInterface)(nil).Begin))
}

// BufferSize mocks base method.
func (m *MockXInterface) BufferSize(size int) *xorm.Session {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "BufferSize", size)
	ret0, _ := ret[0].(*xorm.Session)
	return ret0
}

// BufferSize indicates an expected call of BufferSize.
func (mr *MockXInterfaceMockRecorder) BufferSize(size interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "BufferSize", reflect.TypeOf((*MockXInterface)(nil).BufferSize), size)
}

// Close mocks base method.
func (m *MockXInterface) Close() error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Close")
	ret0, _ := ret[0].(error)
	return ret0
}

// Close indicates an expected call of Close.
func (mr *MockXInterfaceMockRecorder) Close() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Close", reflect.TypeOf((*MockXInterface)(nil).Close))
}

// Cols mocks base method.
func (m *MockXInterface) Cols(columns ...string) *xorm.Session {
	m.ctrl.T.Helper()
	varargs := []interface{}{}
	for _, a := range columns {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "Cols", varargs...)
	ret0, _ := ret[0].(*xorm.Session)
	return ret0
}

// Cols indicates an expected call of Cols.
func (mr *MockXInterfaceMockRecorder) Cols(columns ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Cols", reflect.TypeOf((*MockXInterface)(nil).Cols), columns...)
}

// Commit mocks base method.
func (m *MockXInterface) Commit() error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Commit")
	ret0, _ := ret[0].(error)
	return ret0
}

// Commit indicates an expected call of Commit.
func (mr *MockXInterfaceMockRecorder) Commit() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Commit", reflect.TypeOf((*MockXInterface)(nil).Commit))
}

// Count mocks base method.
func (m *MockXInterface) Count(arg0 ...interface{}) (int64, error) {
	m.ctrl.T.Helper()
	varargs := []interface{}{}
	for _, a := range arg0 {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "Count", varargs...)
	ret0, _ := ret[0].(int64)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Count indicates an expected call of Count.
func (mr *MockXInterfaceMockRecorder) Count(arg0 ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Count", reflect.TypeOf((*MockXInterface)(nil).Count), arg0...)
}

// CreateIndexes mocks base method.
func (m *MockXInterface) CreateIndexes(bean interface{}) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "CreateIndexes", bean)
	ret0, _ := ret[0].(error)
	return ret0
}

// CreateIndexes indicates an expected call of CreateIndexes.
func (mr *MockXInterfaceMockRecorder) CreateIndexes(bean interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CreateIndexes", reflect.TypeOf((*MockXInterface)(nil).CreateIndexes), bean)
}

// CreateUniques mocks base method.
func (m *MockXInterface) CreateUniques(bean interface{}) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "CreateUniques", bean)
	ret0, _ := ret[0].(error)
	return ret0
}

// CreateUniques indicates an expected call of CreateUniques.
func (mr *MockXInterfaceMockRecorder) CreateUniques(bean interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CreateUniques", reflect.TypeOf((*MockXInterface)(nil).CreateUniques), bean)
}

// Decr mocks base method.
func (m *MockXInterface) Decr(column string, arg ...interface{}) *xorm.Session {
	m.ctrl.T.Helper()
	varargs := []interface{}{column}
	for _, a := range arg {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "Decr", varargs...)
	ret0, _ := ret[0].(*xorm.Session)
	return ret0
}

// Decr indicates an expected call of Decr.
func (mr *MockXInterfaceMockRecorder) Decr(column interface{}, arg ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{column}, arg...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Decr", reflect.TypeOf((*MockXInterface)(nil).Decr), varargs...)
}

// Delete mocks base method.
func (m *MockXInterface) Delete(arg0 ...interface{}) (int64, error) {
	m.ctrl.T.Helper()
	varargs := []interface{}{}
	for _, a := range arg0 {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "Delete", varargs...)
	ret0, _ := ret[0].(int64)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Delete indicates an expected call of Delete.
func (mr *MockXInterfaceMockRecorder) Delete(arg0 ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Delete", reflect.TypeOf((*MockXInterface)(nil).Delete), arg0...)
}

// Desc mocks base method.
func (m *MockXInterface) Desc(arg0 ...string) *xorm.Session {
	m.ctrl.T.Helper()
	varargs := []interface{}{}
	for _, a := range arg0 {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "Desc", varargs...)
	ret0, _ := ret[0].(*xorm.Session)
	return ret0
}

// Desc indicates an expected call of Desc.
func (mr *MockXInterfaceMockRecorder) Desc(arg0 ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Desc", reflect.TypeOf((*MockXInterface)(nil).Desc), arg0...)
}

// Distinct mocks base method.
func (m *MockXInterface) Distinct(columns ...string) *xorm.Session {
	m.ctrl.T.Helper()
	varargs := []interface{}{}
	for _, a := range columns {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "Distinct", varargs...)
	ret0, _ := ret[0].(*xorm.Session)
	return ret0
}

// Distinct indicates an expected call of Distinct.
func (mr *MockXInterfaceMockRecorder) Distinct(columns ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Distinct", reflect.TypeOf((*MockXInterface)(nil).Distinct), columns...)
}

// DropIndexes mocks base method.
func (m *MockXInterface) DropIndexes(bean interface{}) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "DropIndexes", bean)
	ret0, _ := ret[0].(error)
	return ret0
}

// DropIndexes indicates an expected call of DropIndexes.
func (mr *MockXInterfaceMockRecorder) DropIndexes(bean interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "DropIndexes", reflect.TypeOf((*MockXInterface)(nil).DropIndexes), bean)
}

// Exec mocks base method.
func (m *MockXInterface) Exec(sqlOrArgs ...interface{}) (sql.Result, error) {
	m.ctrl.T.Helper()
	varargs := []interface{}{}
	for _, a := range sqlOrArgs {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "Exec", varargs...)
	ret0, _ := ret[0].(sql.Result)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Exec indicates an expected call of Exec.
func (mr *MockXInterfaceMockRecorder) Exec(sqlOrArgs ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Exec", reflect.TypeOf((*MockXInterface)(nil).Exec), sqlOrArgs...)
}

// Exist mocks base method.
func (m *MockXInterface) Exist(bean ...interface{}) (bool, error) {
	m.ctrl.T.Helper()
	varargs := []interface{}{}
	for _, a := range bean {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "Exist", varargs...)
	ret0, _ := ret[0].(bool)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Exist indicates an expected call of Exist.
func (mr *MockXInterfaceMockRecorder) Exist(bean ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Exist", reflect.TypeOf((*MockXInterface)(nil).Exist), bean...)
}

// Find mocks base method.
func (m *MockXInterface) Find(arg0 interface{}, arg1 ...interface{}) error {
	m.ctrl.T.Helper()
	varargs := []interface{}{arg0}
	for _, a := range arg1 {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "Find", varargs...)
	ret0, _ := ret[0].(error)
	return ret0
}

// Find indicates an expected call of Find.
func (mr *MockXInterfaceMockRecorder) Find(arg0 interface{}, arg1 ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{arg0}, arg1...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Find", reflect.TypeOf((*MockXInterface)(nil).Find), varargs...)
}

// FindAndCount mocks base method.
func (m *MockXInterface) FindAndCount(arg0 interface{}, arg1 ...interface{}) (int64, error) {
	m.ctrl.T.Helper()
	varargs := []interface{}{arg0}
	for _, a := range arg1 {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "FindAndCount", varargs...)
	ret0, _ := ret[0].(int64)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// FindAndCount indicates an expected call of FindAndCount.
func (mr *MockXInterfaceMockRecorder) FindAndCount(arg0 interface{}, arg1 ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{arg0}, arg1...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "FindAndCount", reflect.TypeOf((*MockXInterface)(nil).FindAndCount), varargs...)
}

// Get mocks base method.
func (m *MockXInterface) Get(arg0 ...interface{}) (bool, error) {
	m.ctrl.T.Helper()
	varargs := []interface{}{}
	for _, a := range arg0 {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "Get", varargs...)
	ret0, _ := ret[0].(bool)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Get indicates an expected call of Get.
func (mr *MockXInterfaceMockRecorder) Get(arg0 ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Get", reflect.TypeOf((*MockXInterface)(nil).Get), arg0...)
}

// GroupBy mocks base method.
func (m *MockXInterface) GroupBy(keys string) *xorm.Session {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GroupBy", keys)
	ret0, _ := ret[0].(*xorm.Session)
	return ret0
}

// GroupBy indicates an expected call of GroupBy.
func (mr *MockXInterfaceMockRecorder) GroupBy(keys interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GroupBy", reflect.TypeOf((*MockXInterface)(nil).GroupBy), keys)
}

// ID mocks base method.
func (m *MockXInterface) ID(arg0 interface{}) *xorm.Session {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "ID", arg0)
	ret0, _ := ret[0].(*xorm.Session)
	return ret0
}

// ID indicates an expected call of ID.
func (mr *MockXInterfaceMockRecorder) ID(arg0 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ID", reflect.TypeOf((*MockXInterface)(nil).ID), arg0)
}

// In mocks base method.
func (m *MockXInterface) In(arg0 string, arg1 ...interface{}) *xorm.Session {
	m.ctrl.T.Helper()
	varargs := []interface{}{arg0}
	for _, a := range arg1 {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "In", varargs...)
	ret0, _ := ret[0].(*xorm.Session)
	return ret0
}

// In indicates an expected call of In.
func (mr *MockXInterfaceMockRecorder) In(arg0 interface{}, arg1 ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{arg0}, arg1...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "In", reflect.TypeOf((*MockXInterface)(nil).In), varargs...)
}

// Incr mocks base method.
func (m *MockXInterface) Incr(column string, arg ...interface{}) *xorm.Session {
	m.ctrl.T.Helper()
	varargs := []interface{}{column}
	for _, a := range arg {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "Incr", varargs...)
	ret0, _ := ret[0].(*xorm.Session)
	return ret0
}

// Incr indicates an expected call of Incr.
func (mr *MockXInterfaceMockRecorder) Incr(column interface{}, arg ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{column}, arg...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Incr", reflect.TypeOf((*MockXInterface)(nil).Incr), varargs...)
}

// Insert mocks base method.
func (m *MockXInterface) Insert(arg0 ...interface{}) (int64, error) {
	m.ctrl.T.Helper()
	varargs := []interface{}{}
	for _, a := range arg0 {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "Insert", varargs...)
	ret0, _ := ret[0].(int64)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Insert indicates an expected call of Insert.
func (mr *MockXInterfaceMockRecorder) Insert(arg0 ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Insert", reflect.TypeOf((*MockXInterface)(nil).Insert), arg0...)
}

// InsertOne mocks base method.
func (m *MockXInterface) InsertOne(arg0 interface{}) (int64, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "InsertOne", arg0)
	ret0, _ := ret[0].(int64)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// InsertOne indicates an expected call of InsertOne.
func (mr *MockXInterfaceMockRecorder) InsertOne(arg0 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "InsertOne", reflect.TypeOf((*MockXInterface)(nil).InsertOne), arg0)
}

// IsTableEmpty mocks base method.
func (m *MockXInterface) IsTableEmpty(bean interface{}) (bool, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "IsTableEmpty", bean)
	ret0, _ := ret[0].(bool)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// IsTableEmpty indicates an expected call of IsTableEmpty.
func (mr *MockXInterfaceMockRecorder) IsTableEmpty(bean interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "IsTableEmpty", reflect.TypeOf((*MockXInterface)(nil).IsTableEmpty), bean)
}

// IsTableExist mocks base method.
func (m *MockXInterface) IsTableExist(beanOrTableName interface{}) (bool, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "IsTableExist", beanOrTableName)
	ret0, _ := ret[0].(bool)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// IsTableExist indicates an expected call of IsTableExist.
func (mr *MockXInterfaceMockRecorder) IsTableExist(beanOrTableName interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "IsTableExist", reflect.TypeOf((*MockXInterface)(nil).IsTableExist), beanOrTableName)
}

// Iterate mocks base method.
func (m *MockXInterface) Iterate(arg0 interface{}, arg1 xorm.IterFunc) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Iterate", arg0, arg1)
	ret0, _ := ret[0].(error)
	return ret0
}

// Iterate indicates an expected call of Iterate.
func (mr *MockXInterfaceMockRecorder) Iterate(arg0, arg1 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Iterate", reflect.TypeOf((*MockXInterface)(nil).Iterate), arg0, arg1)
}

// Join mocks base method.
func (m *MockXInterface) Join(joinOperator string, tablename interface{}, condition string, args ...interface{}) *xorm.Session {
	m.ctrl.T.Helper()
	varargs := []interface{}{joinOperator, tablename, condition}
	for _, a := range args {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "Join", varargs...)
	ret0, _ := ret[0].(*xorm.Session)
	return ret0
}

// Join indicates an expected call of Join.
func (mr *MockXInterfaceMockRecorder) Join(joinOperator, tablename, condition interface{}, args ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{joinOperator, tablename, condition}, args...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Join", reflect.TypeOf((*MockXInterface)(nil).Join), varargs...)
}

// Limit mocks base method.
func (m *MockXInterface) Limit(arg0 int, arg1 ...int) *xorm.Session {
	m.ctrl.T.Helper()
	varargs := []interface{}{arg0}
	for _, a := range arg1 {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "Limit", varargs...)
	ret0, _ := ret[0].(*xorm.Session)
	return ret0
}

// Limit indicates an expected call of Limit.
func (mr *MockXInterfaceMockRecorder) Limit(arg0 interface{}, arg1 ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{arg0}, arg1...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Limit", reflect.TypeOf((*MockXInterface)(nil).Limit), varargs...)
}

// MustCols mocks base method.
func (m *MockXInterface) MustCols(columns ...string) *xorm.Session {
	m.ctrl.T.Helper()
	varargs := []interface{}{}
	for _, a := range columns {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "MustCols", varargs...)
	ret0, _ := ret[0].(*xorm.Session)
	return ret0
}

// MustCols indicates an expected call of MustCols.
func (mr *MockXInterfaceMockRecorder) MustCols(columns ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "MustCols", reflect.TypeOf((*MockXInterface)(nil).MustCols), columns...)
}

// NoAutoCondition mocks base method.
func (m *MockXInterface) NoAutoCondition(arg0 ...bool) *xorm.Session {
	m.ctrl.T.Helper()
	varargs := []interface{}{}
	for _, a := range arg0 {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "NoAutoCondition", varargs...)
	ret0, _ := ret[0].(*xorm.Session)
	return ret0
}

// NoAutoCondition indicates an expected call of NoAutoCondition.
func (mr *MockXInterfaceMockRecorder) NoAutoCondition(arg0 ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "NoAutoCondition", reflect.TypeOf((*MockXInterface)(nil).NoAutoCondition), arg0...)
}

// NotIn mocks base method.
func (m *MockXInterface) NotIn(arg0 string, arg1 ...interface{}) *xorm.Session {
	m.ctrl.T.Helper()
	varargs := []interface{}{arg0}
	for _, a := range arg1 {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "NotIn", varargs...)
	ret0, _ := ret[0].(*xorm.Session)
	return ret0
}

// NotIn indicates an expected call of NotIn.
func (mr *MockXInterfaceMockRecorder) NotIn(arg0 interface{}, arg1 ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{arg0}, arg1...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "NotIn", reflect.TypeOf((*MockXInterface)(nil).NotIn), varargs...)
}

// Nullable mocks base method.
func (m *MockXInterface) Nullable(arg0 ...string) *xorm.Session {
	m.ctrl.T.Helper()
	varargs := []interface{}{}
	for _, a := range arg0 {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "Nullable", varargs...)
	ret0, _ := ret[0].(*xorm.Session)
	return ret0
}

// Nullable indicates an expected call of Nullable.
func (mr *MockXInterfaceMockRecorder) Nullable(arg0 ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Nullable", reflect.TypeOf((*MockXInterface)(nil).Nullable), arg0...)
}

// Omit mocks base method.
func (m *MockXInterface) Omit(columns ...string) *xorm.Session {
	m.ctrl.T.Helper()
	varargs := []interface{}{}
	for _, a := range columns {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "Omit", varargs...)
	ret0, _ := ret[0].(*xorm.Session)
	return ret0
}

// Omit indicates an expected call of Omit.
func (mr *MockXInterfaceMockRecorder) Omit(columns ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Omit", reflect.TypeOf((*MockXInterface)(nil).Omit), columns...)
}

// OrderBy mocks base method.
func (m *MockXInterface) OrderBy(order interface{}, args ...interface{}) *xorm.Session {
	m.ctrl.T.Helper()
	varargs := []interface{}{order}
	for _, a := range args {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "OrderBy", varargs...)
	ret0, _ := ret[0].(*xorm.Session)
	return ret0
}

// OrderBy indicates an expected call of OrderBy.
func (mr *MockXInterfaceMockRecorder) OrderBy(order interface{}, args ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{order}, args...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "OrderBy", reflect.TypeOf((*MockXInterface)(nil).OrderBy), varargs...)
}

// Ping mocks base method.
func (m *MockXInterface) Ping() error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Ping")
	ret0, _ := ret[0].(error)
	return ret0
}

// Ping indicates an expected call of Ping.
func (mr *MockXInterfaceMockRecorder) Ping() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Ping", reflect.TypeOf((*MockXInterface)(nil).Ping))
}

// Query mocks base method.
func (m *MockXInterface) Query(sqlOrArgs ...interface{}) ([]map[string][]byte, error) {
	m.ctrl.T.Helper()
	varargs := []interface{}{}
	for _, a := range sqlOrArgs {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "Query", varargs...)
	ret0, _ := ret[0].([]map[string][]byte)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Query indicates an expected call of Query.
func (mr *MockXInterfaceMockRecorder) Query(sqlOrArgs ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Query", reflect.TypeOf((*MockXInterface)(nil).Query), sqlOrArgs...)
}

// QueryInterface mocks base method.
func (m *MockXInterface) QueryInterface(sqlOrArgs ...interface{}) ([]map[string]interface{}, error) {
	m.ctrl.T.Helper()
	varargs := []interface{}{}
	for _, a := range sqlOrArgs {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "QueryInterface", varargs...)
	ret0, _ := ret[0].([]map[string]interface{})
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// QueryInterface indicates an expected call of QueryInterface.
func (mr *MockXInterfaceMockRecorder) QueryInterface(sqlOrArgs ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "QueryInterface", reflect.TypeOf((*MockXInterface)(nil).QueryInterface), sqlOrArgs...)
}

// QueryString mocks base method.
func (m *MockXInterface) QueryString(sqlOrArgs ...interface{}) ([]map[string]string, error) {
	m.ctrl.T.Helper()
	varargs := []interface{}{}
	for _, a := range sqlOrArgs {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "QueryString", varargs...)
	ret0, _ := ret[0].([]map[string]string)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// QueryString indicates an expected call of QueryString.
func (mr *MockXInterfaceMockRecorder) QueryString(sqlOrArgs ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "QueryString", reflect.TypeOf((*MockXInterface)(nil).QueryString), sqlOrArgs...)
}

// Rollback mocks base method.
func (m *MockXInterface) Rollback() error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Rollback")
	ret0, _ := ret[0].(error)
	return ret0
}

// Rollback indicates an expected call of Rollback.
func (mr *MockXInterfaceMockRecorder) Rollback() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Rollback", reflect.TypeOf((*MockXInterface)(nil).Rollback))
}

// Rows mocks base method.
func (m *MockXInterface) Rows(bean interface{}) (*xorm.Rows, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Rows", bean)
	ret0, _ := ret[0].(*xorm.Rows)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Rows indicates an expected call of Rows.
func (mr *MockXInterfaceMockRecorder) Rows(bean interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Rows", reflect.TypeOf((*MockXInterface)(nil).Rows), bean)
}

// SQL mocks base method.
func (m *MockXInterface) SQL(arg0 interface{}, arg1 ...interface{}) *xorm.Session {
	m.ctrl.T.Helper()
	varargs := []interface{}{arg0}
	for _, a := range arg1 {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "SQL", varargs...)
	ret0, _ := ret[0].(*xorm.Session)
	return ret0
}

// SQL indicates an expected call of SQL.
func (mr *MockXInterfaceMockRecorder) SQL(arg0 interface{}, arg1 ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{arg0}, arg1...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SQL", reflect.TypeOf((*MockXInterface)(nil).SQL), varargs...)
}

// Select mocks base method.
func (m *MockXInterface) Select(arg0 string) *xorm.Session {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Select", arg0)
	ret0, _ := ret[0].(*xorm.Session)
	return ret0
}

// Select indicates an expected call of Select.
func (mr *MockXInterfaceMockRecorder) Select(arg0 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Select", reflect.TypeOf((*MockXInterface)(nil).Select), arg0)
}

// SetExpr mocks base method.
func (m *MockXInterface) SetExpr(arg0 string, arg1 interface{}) *xorm.Session {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "SetExpr", arg0, arg1)
	ret0, _ := ret[0].(*xorm.Session)
	return ret0
}

// SetExpr indicates an expected call of SetExpr.
func (mr *MockXInterfaceMockRecorder) SetExpr(arg0, arg1 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SetExpr", reflect.TypeOf((*MockXInterface)(nil).SetExpr), arg0, arg1)
}

// Sum mocks base method.
func (m *MockXInterface) Sum(bean interface{}, colName string) (float64, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Sum", bean, colName)
	ret0, _ := ret[0].(float64)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Sum indicates an expected call of Sum.
func (mr *MockXInterfaceMockRecorder) Sum(bean, colName interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Sum", reflect.TypeOf((*MockXInterface)(nil).Sum), bean, colName)
}

// SumInt mocks base method.
func (m *MockXInterface) SumInt(bean interface{}, colName string) (int64, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "SumInt", bean, colName)
	ret0, _ := ret[0].(int64)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// SumInt indicates an expected call of SumInt.
func (mr *MockXInterfaceMockRecorder) SumInt(bean, colName interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SumInt", reflect.TypeOf((*MockXInterface)(nil).SumInt), bean, colName)
}

// Sums mocks base method.
func (m *MockXInterface) Sums(bean interface{}, colNames ...string) ([]float64, error) {
	m.ctrl.T.Helper()
	varargs := []interface{}{bean}
	for _, a := range colNames {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "Sums", varargs...)
	ret0, _ := ret[0].([]float64)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Sums indicates an expected call of Sums.
func (mr *MockXInterfaceMockRecorder) Sums(bean interface{}, colNames ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{bean}, colNames...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Sums", reflect.TypeOf((*MockXInterface)(nil).Sums), varargs...)
}

// SumsInt mocks base method.
func (m *MockXInterface) SumsInt(bean interface{}, colNames ...string) ([]int64, error) {
	m.ctrl.T.Helper()
	varargs := []interface{}{bean}
	for _, a := range colNames {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "SumsInt", varargs...)
	ret0, _ := ret[0].([]int64)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// SumsInt indicates an expected call of SumsInt.
func (mr *MockXInterfaceMockRecorder) SumsInt(bean interface{}, colNames ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{bean}, colNames...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SumsInt", reflect.TypeOf((*MockXInterface)(nil).SumsInt), varargs...)
}

// Table mocks base method.
func (m *MockXInterface) Table(tableNameOrBean interface{}) *xorm.Session {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Table", tableNameOrBean)
	ret0, _ := ret[0].(*xorm.Session)
	return ret0
}

// Table indicates an expected call of Table.
func (mr *MockXInterfaceMockRecorder) Table(tableNameOrBean interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Table", reflect.TypeOf((*MockXInterface)(nil).Table), tableNameOrBean)
}

// Unscoped mocks base method.
func (m *MockXInterface) Unscoped() *xorm.Session {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Unscoped")
	ret0, _ := ret[0].(*xorm.Session)
	return ret0
}

// Unscoped indicates an expected call of Unscoped.
func (mr *MockXInterfaceMockRecorder) Unscoped() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Unscoped", reflect.TypeOf((*MockXInterface)(nil).Unscoped))
}

// Update mocks base method.
func (m *MockXInterface) Update(bean interface{}, condiBeans ...interface{}) (int64, error) {
	m.ctrl.T.Helper()
	varargs := []interface{}{bean}
	for _, a := range condiBeans {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "Update", varargs...)
	ret0, _ := ret[0].(int64)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Update indicates an expected call of Update.
func (mr *MockXInterfaceMockRecorder) Update(bean interface{}, condiBeans ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{bean}, condiBeans...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Update", reflect.TypeOf((*MockXInterface)(nil).Update), varargs...)
}

// UseBool mocks base method.
func (m *MockXInterface) UseBool(arg0 ...string) *xorm.Session {
	m.ctrl.T.Helper()
	varargs := []interface{}{}
	for _, a := range arg0 {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "UseBool", varargs...)
	ret0, _ := ret[0].(*xorm.Session)
	return ret0
}

// UseBool indicates an expected call of UseBool.
func (mr *MockXInterfaceMockRecorder) UseBool(arg0 ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "UseBool", reflect.TypeOf((*MockXInterface)(nil).UseBool), arg0...)
}

// Where mocks base method.
func (m *MockXInterface) Where(arg0 interface{}, arg1 ...interface{}) *xorm.Session {
	m.ctrl.T.Helper()
	varargs := []interface{}{arg0}
	for _, a := range arg1 {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "Where", varargs...)
	ret0, _ := ret[0].(*xorm.Session)
	return ret0
}

// Where indicates an expected call of Where.
func (mr *MockXInterfaceMockRecorder) Where(arg0 interface{}, arg1 ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{arg0}, arg1...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Where", reflect.TypeOf((*MockXInterface)(nil).Where), varargs...)
}
